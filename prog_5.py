#!/usr/bin/env python -utt
# coding: utf-8

from datetime import datetime
import os




def find_maximum(lst):
	'''
	Эта функция - аналог функции max - находит
	максимальный элемент в списке
	
	Вопрос 1: найдите ошибку и исправьте
	'''
	for a in lst:
		if a > max_a:
			max_a = a
	return max_a
	
## 2. Создать функции:
##      find_minimum       - находит минимальный элемент
##      calc_same_count    - считает количество таких же элементов (
##                           добавить второй аргумент, с которым сравнивать)
##      sort			   - сортирует от минимального к максимальному
##		limit_values_upper - все элементы меньше заданного приравнивает к заданному
##		limit_values_lower - все элементы больше заданного приравнивает к заданному
##		limit_in_range     - по аналогии лимитирует в диапазоне от и до
## 3. Уровень 2:
##		make_groups		   - задается размер группы, список делится на списки со
##							 значениями, укладывающимися в этот размер
##		make_groups_dicts  - то же в общий словарь, ключ словаря - это кортеж с
##						     минимумом и максимумом группы
##		make_sorted_groups - группы в списке, отсортировать по количеству элементов


	
def choose_by_dict(key, d):
	'''
	Аналог метода словаря d.get(key) - возвращает
	элемент словаря по ключу - в случае, если такого
	элемента нет, выдает None - вместо возбуждения
	исключения
	
	Вопрос 4: упростите, убрав else
	'''
	if key in d:
		return d[key]
	else:
		return None
		
		
		
# 5. Создать функцию, берущую из словаря значение по ключу,
#    Если такого ключа нет, то выдавать значение из заданного
#    кортежа значений по-умолчанию. Значения из него брать по
#    очереди.




def take_from_dict(d, key):
	'''
	Выдает значение словаря по ключу и удаляет его из словаря
	- аналог метода словаря d.pop(key)
	
	Вопрос 6: исправить МНОГО ошибок, добавить значение по-умолчанию
	'''
	return d[key]
	if key not in d:
		del d[key]
		
		
		
		
def insert_in_dict_if_no(d, key, value):
	'''
	Аналог метода словаря d.setdefault(key, default)
	'''
	if key in d:
		return d[key]
	else:
		d[key] = value
		return value
		
## 7. Создать по аналогии функцию, добавляющую значение в
##    список, только если такого значения там нет
## 8. Создать функцию, фильтрующую список по списку "банлиста",
##    То есть если элемент присутствует в банлисте, то удалять
##	  элемент из списка





def del_list_item_by_index(lst, i):
	'''
	Удаляет элемент по индексу
	
	Вопрос 9: добавить проверку на существование элемента
	'''
	del lst[i]
	
	
	
	
def del_list_item(lst, x):
	'''
	Аналог метода списка lst.remove(x)
	
	Вопрос 10: добавить проверки и исправить кое-что еще...
	
	Вопрос 11: сравнить поведение с поведением lst.remove(x), в чем разница?
	'''
	for i, a in enumerate(lst):
		if a == x:
			del lst[i]
			
			
			
		
## -- Рекурсия -- ##
		
def calc_dir_size(path):
	'''
	Получает общий размер текущей директории с байтах -
	Пробегает все файлы в директории, если встречает директорию,
	то заходит в нее рекурсией
	
	Вопрос 12: найдите ошибку и исправьте
	'''
	sum_size = 0
	for filename in os.listdir(path):
		fullpath = path + "/" + filename
		
		if os.path.isdir(filename):
			# если это папка, то заходим в нее и суммируем размеры
			# всех файлов в ней
			sum_size += calc_dir_size(fullpath)
			
		elif os.path.isfile(filename):
			# если это файл, то берем его размер и добавляем к сумме
			sum_size += os.path.getsize(fullpath)
	
	
## 13. По аналогии создать функцию find_max_file. Эта функция должна
## находить самый большой файл и выдавать его имя и размер
## 14. По аналогии создать функцию files_sorted_by_size. Эта функция должна
## создавать список из всех файлов директории, сортируя его по размеру файлов


## -- Значения по-умолчанию -- ##

def get_like_procent(s1, s2):
	'''
	Считает "похожесть" двух строк в процентном соотношении
	
	Вопрос 15: исправить ошибки
	
	Вопрос 16: добавить в функцию аргумент (по-умолчанию False), в случае если он True,
	то считать процент от максимальной длины строки
	'''
	like_count = 0
	for ch1, ch2 in zip(s1, s2):
		if ch1 == ch2:
			like_count += 1
	return float(count) * float(like_count) / float(count)
	
	
	

# 17. Написать функцию, принимающую на вход любое количество списков.
# Результатом ее выполнения должен быть список кортежей, таких что:
# Кортеж 1 = (Элемент списка 1, Элемент списка 2...)
# - это получится аналог встроенной функции zip




def parse_list_in_groups(lst, only_size=2):
	'''
	Данная функция возвращает список кортежей-групп, в которые по очередно входило
	до only_size элементов из списка. Сначала элементы один за другим идут в 1-ую
	группу, после заполнения группы элементы идут в следующую и тд. 
	
	Конструкция zip(*lst) производит обратное действие по сравнению с zip(lst), 
	распаковывая список кортежей в общий список, 
	
	Конструкция iter(lst) создает объект-итератор прохода по элементам списка
	
	Конструкция [] * n дублирует элементы списка n раз
	
	Вопрос 18: исправить ошибки по смыслу
	'''
	zip(*[iter(lst)]*2)
	
	
	
	
def check_file_loop(filename, every_sec=1):
	'''
	Функция периодически проверяет существование файла и выводит на экран
	информацию об этом
	
	Вопрос 19: Вывод на экран не соответствует поведению. Исправить поведение.
	'''
	import time
	while True:
		if os.path.exists(filename):
			print u"Файл {} был создан: {}".format(filename, datetime.now())
		else:
			print u"Файл {} был удален: {}".format(filename, datetime.now())
		time.sleep(every_sec)
	
	
## -- Переменное количество аргументов -- ##
	
# 20. По аналогии создать функцию, следящую за списком файлов
# 21. Создать функцию, принимающую на вход переменное количество аргументов
#     Если очередной аргумент строка, то использовать его как имя файла.
#     Если список или кортеж - следить за каждым из списка
#     Проверяется следующим образом: type(s) == str

# 22. Создать аналогичную функцию. Логику проверки (if-else) выделить
#     во вложенную функцию.
# 23. принимать на вход переменное количество именованных аргументов (**kwargs)
#     Если задан аргумент 'func', использовать его вместо вложенной
#     функции. Если задан аргумент 'funcs', то считать его списком и
#     выполнять все функции списка по очереди


# Следующая функция разделяет строку на список строк
split_string = lambda s, sep: s.split(sep)

# Следующая функция разделяет строку на список чисел и суммирует
sum_ints_in_string = lambda s, sep: sum([int(a) for a in s.split(sep)])

# Следующая функция суммирует первые два аргумента и умножает на 3-ий
sum_mnoz = lambda a, b, c: (a + b) * c


def show_file_create_text(filename, text=u"Файл {} был создан: {}"):
	print text.format(filename, datetime.now())

# 24. Вложенную функию заменить на:
def check_file_loop_func(filename, d={
			True: lambda filename: show_file_create_text(filename),
			False: lambda filename: show_file_create_text(filename, text=u"Файл {} был удален: {}"),
		}):
	'''
	Принимает на вход словарь с функциями реакции на существование файла
	
	Вопрос 25: добавить проверку существования ключа в d
	'''
	if os.path.exists(filename):
		d[True](filename)
	else:
		d[False](filename)


## -- Области видимости -- ##

FILE_CREATE_COUNT = 0

def count_any_file_creating(filename):
	'''
	Функция прибавляет общий счетчик создания любого файла
	
	Вопрос 25: Исправить ошибку
	'''
	FILE_CREATE_COUNT += 1
	
def print_count_afc(filename):
	'''
	Вывод счетчика на экран
	'''
	print u"Файл", filename ,"создан", FILE_CREATE_COUNT, "раз"
	
# 26. Применить к check_file_loop_func и check_file_loop


	
## -- + Замыкания -- ##
	
def make_counter():
	'''
	Создает счетчик в виде списка (для изменения из вложенных функций)
	и функции прибавления счетчика и вывода его на экран
	
	Вопрос 27: исправить ошибки
	'''
	count = [0,]

	def count_afc(filename):
		count += 1
		
	return count_afc, print_count_afc
		
# 28. Применить к check_file_loop_func и check_file_loop	


# 29. Сделать то же, но со словарем счетчиков - по имени файла


# 30. По этому принципу сделать все необходимые функции для реализации сле-
#     дующей логики:
#     - Первичный проход по папке и подпапкам,
# 	  - Создание счетчика для каждого файла,
#     - Кроме количества созданий хранить последнее состояние (существует/нет)
#       и дату последнего удаления
#     - Для папок следить за созданием новых (неизвестных) файлов
#     - Добавлять счетчик для нового файла


# 31. То же самое для html странички.
#     = помнить структуру дерева html и вести историю изменений
#     - счетчики по именам тэгов
#     - информация о количестве тэгов в документе


		
if __name__=='__main__':
	# При запуске модуля как программы посчитаем размер текущей
	# директории и выведем на экран

	print u'Размер директории "%s" = %d байт' % (
		os.path.abspath('.'),
		calc_dir_size('.'),
	)
